"use strict";var M=(J,T,w)=>new Promise((N,m)=>{var g=y=>{try{X(w.next(y))}catch(B){m(B)}},i=y=>{try{X(w.throw(y))}catch(B){m(B)}},X=y=>y.done?N(y.value):Promise.resolve(y.value).then(g,i);X((w=w.apply(J,T)).next())});(self.webpackChunkpro_react_admin=self.webpackChunkpro_react_admin||[]).push([[7644],{69368:function(J,T,w){w.d(T,{c:function(){return d}});var N=w(49360),m=w(49103),g=4;function i(h){return(0,m.Z)(h,g)}var X=i,y=w(43836),B=w(95351);function d(h){var v={options:{directed:h.isDirected(),multigraph:h.isMultigraph(),compound:h.isCompound()},nodes:E(h),edges:L(h)};return N.Z(h.graph())||(v.value=X(h.graph())),v}function E(h){return y.Z(h.nodes(),function(v){var x=h.node(v),D=h.parent(v),O={v};return N.Z(x)||(O.value=x),N.Z(D)||(O.parent=D),O})}function L(h){return y.Z(h.edges(),function(v){var x=h.edge(v),D={v:v.v,w:v.w};return N.Z(v.name)||(D.name=v.name),N.Z(x)||(D.value=x),D})}function p(h){var v=new Graph(h.options).setGraph(h.value);return _.each(h.nodes,function(x){v.setNode(x.v,x.value),x.parent&&v.setParent(x.v,x.parent)}),_.each(h.edges,function(x){v.setEdge({v:x.v,w:x.w,name:x.name},x.value)}),v}},7644:function(J,T,w){w.d(T,{r:function(){return H}});var N=w(33771),m=w(69368),g=w(80580),i=w(92999),X=w(45625),y=w(25023),B=w(24631);let d={},E={},L={};const p=()=>{E={},L={},d={}},h=(n,t)=>(i.l.trace("In isDecendant",t," ",n," = ",E[t].includes(n)),!!E[t].includes(n)),v=(n,t)=>(i.l.info("Decendants of ",t," is ",E[t]),i.l.info("Edge is ",n),n.v===t||n.w===t?!1:E[t]?E[t].includes(n.v)||h(n.v,t)||h(n.w,t)||E[t].includes(n.w):(i.l.debug("Tilt, ",t,",not in decendants"),!1)),x=(n,t,e,c)=>{i.l.warn("Copying children of ",n,"root",c,"data",t.node(n),c);const s=t.children(n)||[];n!==c&&s.push(n),i.l.warn("Copying (nodes) clusterId",n,"nodes",s),s.forEach(l=>{if(t.children(l).length>0)x(l,t,e,c);else{const f=t.node(l);i.l.info("cp ",l," to ",c," with parent ",n),e.setNode(l,f),c!==t.parent(l)&&(i.l.warn("Setting parent",l,t.parent(l)),e.setParent(l,t.parent(l))),n!==c&&l!==n?(i.l.debug("Setting parent",l,n),e.setParent(l,n)):(i.l.info("In copy ",n,"root",c,"data",t.node(n),c),i.l.debug("Not Setting parent for node=",l,"cluster!==rootId",n!==c,"node!==clusterId",l!==n));const o=t.edges(l);i.l.debug("Copying Edges",o),o.forEach(u=>{i.l.info("Edge",u);const b=t.edge(u.v,u.w,u.name);i.l.info("Edge data",b,c);try{v(u,c)?(i.l.info("Copying as ",u.v,u.w,b,u.name),e.setEdge(u.v,u.w,b,u.name),i.l.info("newGraph edges ",e.edges(),e.edge(e.edges()[0]))):i.l.info("Skipping copy of edge ",u.v,"-->",u.w," rootId: ",c," clusterId:",n)}catch(C){i.l.error(C)}})}i.l.debug("Removing node",l),t.removeNode(l)})},D=(n,t)=>{const e=t.children(n);let c=[...e];for(const s of e)L[s]=n,c=[...c,...D(s,t)];return c},O=(n,t)=>{i.l.trace("Searching",n);const e=t.children(n);if(i.l.trace("Searching children of id ",n,e),e.length<1)return i.l.trace("This is a valid node",n),n;for(const c of e){const s=O(c,t);if(s)return i.l.trace("Found replacement for",n," => ",s),s}},R=n=>!d[n]||!d[n].externalConnections?n:d[n]?d[n].id:n,U=(n,t)=>{if(!n||t>10){i.l.debug("Opting out, no graph ");return}else i.l.debug("Opting in, graph ");n.nodes().forEach(function(e){n.children(e).length>0&&(i.l.warn("Cluster identified",e," Replacement id in edges: ",O(e,n)),E[e]=D(e,n),d[e]={id:O(e,n),clusterData:n.node(e)})}),n.nodes().forEach(function(e){const c=n.children(e),s=n.edges();c.length>0?(i.l.debug("Cluster identified",e,E),s.forEach(l=>{if(l.v!==e&&l.w!==e){const f=h(l.v,e),o=h(l.w,e);f^o&&(i.l.warn("Edge: ",l," leaves cluster ",e),i.l.warn("Decendants of XXX ",e,": ",E[e]),d[e].externalConnections=!0)}})):i.l.debug("Not a cluster ",e,E)}),n.edges().forEach(function(e){const c=n.edge(e);i.l.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(e)),i.l.warn("Edge "+e.v+" -> "+e.w+": "+JSON.stringify(n.edge(e)));let s=e.v,l=e.w;if(i.l.warn("Fix XXX",d,"ids:",e.v,e.w,"Translating: ",d[e.v]," --- ",d[e.w]),d[e.v]&&d[e.w]&&d[e.v]===d[e.w]){i.l.warn("Fixing and trixing link to self - removing XXX",e.v,e.w,e.name),i.l.warn("Fixing and trixing - removing XXX",e.v,e.w,e.name),s=R(e.v),l=R(e.w),n.removeEdge(e.v,e.w,e.name);const f=e.w+"---"+e.v;n.setNode(f,{domId:f,id:f,labelStyle:"",labelText:c.label,padding:0,shape:"labelRect",style:""});const o=structuredClone(c),u=structuredClone(c);o.label="",o.arrowTypeEnd="none",u.label="",o.fromCluster=e.v,u.toCluster=e.v,n.setEdge(s,f,o,e.name+"-cyclic-special"),n.setEdge(f,l,u,e.name+"-cyclic-special")}else(d[e.v]||d[e.w])&&(i.l.warn("Fixing and trixing - removing XXX",e.v,e.w,e.name),s=R(e.v),l=R(e.w),n.removeEdge(e.v,e.w,e.name),s!==e.v&&(c.fromCluster=e.v),l!==e.w&&(c.toCluster=e.w),i.l.warn("Fix Replacing with XXX",s,l,e.name),n.setEdge(s,l,c,e.name))}),i.l.warn("Adjusted Graph",m.c(n)),F(n,0),i.l.trace(d)},F=(n,t)=>{if(i.l.warn("extractor - ",t,m.c(n),n.children("D")),t>10){i.l.error("Bailing out");return}let e=n.nodes(),c=!1;for(const s of e){const l=n.children(s);c=c||l.length>0}if(!c){i.l.debug("Done, no node has children",n.nodes());return}i.l.debug("Nodes = ",e,t);for(const s of e)if(i.l.debug("Extracting node",s,d,d[s]&&!d[s].externalConnections,!n.parent(s),n.node(s),n.children("D")," Depth ",t),!d[s])i.l.debug("Not a cluster",s,t);else if(!d[s].externalConnections&&n.children(s)&&n.children(s).length>0){i.l.warn("Cluster without external connections, without a parent and with children",s,t);let f=n.graph().rankdir==="TB"?"LR":"TB";d[s]&&d[s].clusterData&&d[s].clusterData.dir&&(f=d[s].clusterData.dir,i.l.warn("Fixing dir",d[s].clusterData.dir,f));const o=new X.k({multigraph:!0,compound:!0}).setGraph({rankdir:f,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});i.l.warn("Old graph before copy",m.c(n)),x(s,n,o,s),n.setNode(s,{clusterNode:!0,id:s,clusterData:d[s].clusterData,labelText:d[s].labelText,graph:o}),i.l.warn("New graph after copy node: (",s,")",m.c(o)),i.l.debug("Old graph after copy",m.c(n))}else i.l.warn("Cluster ** ",s," **not meeting the criteria !externalConnections:",!d[s].externalConnections," no parent: ",!n.parent(s)," children ",n.children(s)&&n.children(s).length>0,n.children("D"),t),i.l.debug(d);e=n.nodes(),i.l.warn("New list of nodes",e);for(const s of e){const l=n.node(s);i.l.warn(" Now next level",s,l),l.clusterNode&&F(l.graph,t+1)}},W=(n,t)=>{if(t.length===0)return[];let e=Object.assign(t);return t.forEach(c=>{const s=n.children(c),l=W(n,s);e=[...e,...l]}),e},Z=n=>W(n,n.children()),G={rect:(n,t)=>{i.l.info("Creating subgraph rect for ",t.id,t);const e=n.insert("g").attr("class","cluster"+(t.class?" "+t.class:"")).attr("id",t.id),c=e.insert("rect",":first-child"),s=(0,i.m)((0,i.c)().flowchart.htmlLabels),l=e.insert("g").attr("class","cluster-label"),f=t.labelType==="markdown"?(0,y.c)(l,t.labelText,{style:t.labelStyle,useHtmlLabels:s}):l.node().appendChild((0,g.c)(t.labelText,t.labelStyle,void 0,!0));let o=f.getBBox();if((0,i.m)((0,i.c)().flowchart.htmlLabels)){const r=f.children[0],a=(0,B.Ys)(f);o=r.getBoundingClientRect(),a.attr("width",o.width),a.attr("height",o.height)}const u=0*t.padding,b=u/2,C=t.width<=o.width+u?o.width+u:t.width;t.width<=o.width+u?t.diff=(o.width-t.width)/2-t.padding/2:t.diff=-t.padding/2,i.l.trace("Data ",t,JSON.stringify(t)),c.attr("style",t.style).attr("rx",t.rx).attr("ry",t.ry).attr("x",t.x-C/2).attr("y",t.y-t.height/2-b).attr("width",C).attr("height",t.height+u),s?l.attr("transform","translate("+(t.x-o.width/2)+", "+(t.y-t.height/2)+")"):l.attr("transform","translate("+t.x+", "+(t.y-t.height/2)+")");const P=c.node().getBBox();return t.width=P.width,t.height=P.height,t.intersect=function(r){return(0,g.i)(t,r)},e},roundedWithTitle:(n,t)=>{const e=n.insert("g").attr("class",t.classes).attr("id",t.id),c=e.insert("rect",":first-child"),s=e.insert("g").attr("class","cluster-label"),l=e.append("rect"),f=s.node().appendChild((0,g.c)(t.labelText,t.labelStyle,void 0,!0));let o=f.getBBox();if((0,i.m)((0,i.c)().flowchart.htmlLabels)){const r=f.children[0],a=(0,B.Ys)(f);o=r.getBoundingClientRect(),a.attr("width",o.width),a.attr("height",o.height)}o=f.getBBox();const u=0*t.padding,b=u/2,C=t.width<=o.width+t.padding?o.width+t.padding:t.width;t.width<=o.width+t.padding?t.diff=(o.width+t.padding*0-t.width)/2:t.diff=-t.padding/2,c.attr("class","outer").attr("x",t.x-C/2-b).attr("y",t.y-t.height/2-b).attr("width",C+u).attr("height",t.height+u),l.attr("class","inner").attr("x",t.x-C/2-b).attr("y",t.y-t.height/2-b+o.height-1).attr("width",C+u).attr("height",t.height+u-o.height-3),s.attr("transform","translate("+(t.x-o.width/2)+", "+(t.y-t.height/2-t.padding/3+((0,i.m)((0,i.c)().flowchart.htmlLabels)?5:3))+")");const P=c.node().getBBox();return t.height=P.height,t.intersect=function(r){return(0,g.i)(t,r)},e},noteGroup:(n,t)=>{const e=n.insert("g").attr("class","note-cluster").attr("id",t.id),c=e.insert("rect",":first-child"),s=0*t.padding,l=s/2;c.attr("rx",t.rx).attr("ry",t.ry).attr("x",t.x-t.width/2-l).attr("y",t.y-t.height/2-l).attr("width",t.width+s).attr("height",t.height+s).attr("fill","none");const f=c.node().getBBox();return t.width=f.width,t.height=f.height,t.intersect=function(o){return(0,g.i)(t,o)},e},divider:(n,t)=>{const e=n.insert("g").attr("class",t.classes).attr("id",t.id),c=e.insert("rect",":first-child"),s=0*t.padding,l=s/2;c.attr("class","divider").attr("x",t.x-t.width/2-l).attr("y",t.y-t.height/2).attr("width",t.width+s).attr("height",t.height+s);const f=c.node().getBBox();return t.width=f.width,t.height=f.height,t.diff=-t.padding/2,t.intersect=function(o){return(0,g.i)(t,o)},e}};let j={};const k=(n,t)=>{i.l.trace("Inserting cluster");const e=t.shape||"rect";j[t.id]=G[e](n,t)},Y=()=>{j={}},K=(n,t,e,c,s)=>M(this,null,function*(){i.l.info("Graph in recursive render: XXX",m.c(t),s);const l=t.graph().rankdir;i.l.trace("Dir in recursive render - dir:",l);const f=n.insert("g").attr("class","root");t.nodes()?i.l.info("Recursive render XXX",t.nodes()):i.l.info("No nodes found for",t),t.edges().length>0&&i.l.trace("Recursive edges",t.edge(t.edges()[0]));const o=f.insert("g").attr("class","clusters"),u=f.insert("g").attr("class","edgePaths"),b=f.insert("g").attr("class","edgeLabels"),C=f.insert("g").attr("class","nodes");yield Promise.all(t.nodes().map(function(r){return M(this,null,function*(){const a=t.node(r);if(s!==void 0){const S=JSON.parse(JSON.stringify(s.clusterData));i.l.info("Setting data for cluster XXX (",r,") ",S,s),t.setNode(s.id,S),t.parent(r)||(i.l.trace("Setting parent",r,s.id),t.setParent(r,s.id,S))}if(i.l.info("(Insert) Node XXX"+r+": "+JSON.stringify(t.node(r))),a&&a.clusterNode){i.l.info("Cluster identified",r,a.width,t.node(r));const S=yield K(C,a.graph,e,c,t.node(r)),A=S.elem;(0,g.u)(a,A),a.diff=S.diff||0,i.l.info("Node bounds (abc123)",r,a,a.width,a.x,a.y),(0,g.s)(A,a),i.l.warn("Recursive render complete ",A,a)}else t.children(r).length>0?(i.l.info("Cluster - the non recursive path XXX",r,a.id,a,t),i.l.info(O(a.id,t)),d[a.id]={id:O(a.id,t),node:a}):(i.l.info("Node - the non recursive path",r,a.id,a),yield(0,g.e)(C,t.node(r),l))})})),t.edges().forEach(function(r){const a=t.edge(r.v,r.w,r.name);i.l.info("Edge "+r.v+" -> "+r.w+": "+JSON.stringify(r)),i.l.info("Edge "+r.v+" -> "+r.w+": ",r," ",JSON.stringify(t.edge(r))),i.l.info("Fix",d,"ids:",r.v,r.w,"Translateing: ",d[r.v],d[r.w]),(0,g.f)(b,a)}),t.edges().forEach(function(r){i.l.info("Edge "+r.v+" -> "+r.w+": "+JSON.stringify(r))}),i.l.info("#############################################"),i.l.info("###                Layout                 ###"),i.l.info("#############################################"),i.l.info(t),(0,N.bK)(t),i.l.info("Graph after layout:",m.c(t));let P=0;return Z(t).forEach(function(r){const a=t.node(r);i.l.info("Position "+r+": "+JSON.stringify(t.node(r))),i.l.info("Position "+r+": ("+a.x,","+a.y,") width: ",a.width," height: ",a.height),a&&a.clusterNode?(0,g.p)(a):t.children(r).length>0?(k(o,a),d[a.id].node=a):(0,g.p)(a)}),t.edges().forEach(function(r){const a=t.edge(r);i.l.info("Edge "+r.v+" -> "+r.w+": "+JSON.stringify(a),a);const S=(0,g.g)(u,r,a,d,e,t,c);(0,g.h)(a,S)}),t.nodes().forEach(function(r){const a=t.node(r);i.l.info(r,a.type,a.diff),a.type==="group"&&(P=a.diff)}),{elem:f,diff:P}}),H=(n,t,e,c,s)=>M(this,null,function*(){(0,g.a)(n,e,c,s),(0,g.b)(),(0,g.d)(),Y(),p(),i.l.warn("Graph at first:",JSON.stringify(m.c(t))),U(t),i.l.warn("Graph after:",JSON.stringify(m.c(t))),yield K(n,t,c,s)})}}]);

//# sourceMappingURL=7644.40373be6d72c65f099d1.js.map